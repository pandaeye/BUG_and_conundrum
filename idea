Idle
move
jump_start
jump_air
jump_end
hit
maic

move-hit         stop start
move-jump        stop start
jump_start-move  wait
jump_start-hit   wait
jump_air-move    wait
jump_air-hit
jump_end-move    wait
jump_end-hit     wait
hit-move         wait
hit-jump         wait

武器
刀，散弹枪，炮
技能与道具融合:
地雷（cd：1s），环绕守护刀（可发射），
侧移
反弹
无敌
霸体
弹反
毒：减速
出血：增加每一击伤害
治疗

class WL_FrameNode
{
pubile:
	virtual void update() = 0;
protected:

}

class scene
{
private:
	//vector<Map*>;
	//vector<Monster*>;
	vector<Player*> m_vecPlayer;
	//vector<Building*>;//breakable
public:
	scene()
	{
		WL_Player* player = new WL_Player();
		m_vecPlayer.push_back(player);
	}
	~scene()
	{
		for(int i = 0;i<m_vecPlayer.size();i++)
		{
			delete m_vecPlayer[i];
			m_vecPlayer[i] = nullptr;
		}
	}
	update()
	{
		inputmanager->update()
		//mapmanager->update()
		for(int i = 0;i<m_vecPlayer.size();i++)
		{
			m_vecPlayer[i]->update();
		}
		m_gCollisionManager->update()
		randermanager->update()
	}
}
bool IsPointInRect(const WL_Point& pt, const WL_Rect rt)
{
	if ((rt.left > pt.x) ||
		(rt.right <= pt.x) ||
		(rt.top > pt.y) ||
		(rt.bottom <= pt.y))
	{
		return false;
	}

	return true;
}
class WL_Monster
{
pricate:
	WL_Animation* m_pAnimation;
	PlayerState m_nState;
	int m_nAnimationID;
	int m_nCurrentFrameIndex;
	int m_nMaxFrame;
	int x;
	int y;
	float angel;
public:
	update()
	{
		if(IsPointInRect(Player->GetPos(), WL_Rect(x, y, x+100, y+100) && !PointInRect(Player->GetPos(), WL_Rect(x, y, x+5, y+5))
		{
			x = drawline().x;
			y = drawline().y;
			m_pAnimation = m_gAnimationManager->CreateAnimation(m_nRoleIDInDB, Run);
			m_nCurrentFrameIndex = 0;
			m_nMaxFrame = m_pAnimation->GetMaxFram();
			m_nState = Run;
		}
		if(IsPointInRect(Player->GetPos(), WL_Rect(x, y, x+5, y+5))
		{
			m_pAnimation = m_gAnimationManager->CreateAnimation(m_nRoleIDInDB, Attack);
			m_nCurrentFrameIndex = 0;
			m_nMaxFrame = m_pAnimation->GetMaxFram();
			m_nState = Attack;
		}
	}
}
class WL_Player
{
pricate:
	vector<int> m_vecCollisionObject;//碰撞时需要处理的对象ID
	const int m_nUUID;
	int m_nID;
	PlayerState m_nState;
	WL_Animation* m_pAnimation;//每个animation在内存中只有一个实体，为了节省内存
	WL_Rander* m_pRander;//决定animation渲染方式，比如屏幕位置，旋转角度，是否反转等
	WL_Item* m_pWeapon;
	WL_Animation* m_pWeaponAnimation;
//	int m_nCurrentFrameIndex;
//	int m_nMaxFrame;
	int x;
	int y;
public:
	WL_Player():m_nRoleIDInDB(1)
	{
		m_nRoleIDInDB = 1;
//		m_pAction = new m_pAction(WL_AnimationState);
		m_nCurrentFrameIndex = 0;
		m_nMaxFrame = 0;
		x = 500;
		y = 500;
	}
	~WL_Plyer()
	{
//		delete m_pAction;
//		m_pAction = nullptr;
	}
	update()
	{
		//Idle
		if(WL_Animation->IsFinish())
		{
			WL_Animation = m_gAnimationManager->CreateAnimation(m_nRoleIDInDB, Idle);
			m_nState = Idle;
			if(m_pWeapon != nullptr)
			{
				m_pWeaponAnimation = m_gAnimationManager->CreateAnimation(m_pWeapon->GetUUID(), Idle);
				m_gCollisionManager->AddObject(m_pWeapon->GetID());
			}
		}
		//input
		bool bRalate = false;
		if(m_gInputManeger->IsPressed(KC_A))
		{
			x -= 2;
			if(m_nState != JumpAir && m_nState != Jump && m_nState != Run)
			{
				WL_Animation = m_gAnimationManager->CreateAnimation(m_nRoleIDInDB, Run);
				m_nState = Run;
				if(m_pWeapon != nullptr)
				{
					m_pWeaponAnimation = m_gAnimationManager->CreateAnimation(m_pWeapon->GetUUID(), Run);
				}
			}
		}
		if(m_gInputManeger->IsPressed(KC_D))
		{
			x++;
			if(m_nState != JumpAir && m_nState != Jump && m_nState != Run)
			{
				m_pAnimation = m_gAnimationManager->CreateAnimation(m_nRoleIDInDB, Run);
				m_nCurrentFrameIndex = 0;
				m_nMaxFrame = m_pAnimation->GetMaxFram();
				m_nState = Run;
			}
			bRalate = true;
		}
		if(m_gInputManeger->IsPressed(KC_M))
		{
			if(m_nState != JumpAir && m_nState != Jump)
			{
				m_pAnimation = m_gAnimationManager->CreateAnimation(m_nRoleIDInDB, Jump);
				m_nCurrentFrameIndex = 0;
				m_nMaxFrame = m_pAnimation->GetMaxFram();
				m_nState = Jump;
			}
			
		}
		if(m_gInputManeger->IsPressed(KC_J))
		{
			if(m_nState != Jump && m_nState != Attack)
			{
				m_pAnimation = m_gAnimationManager->CreateAnimation(m_nRoleIDInDB, Attack);
				m_nCurrentFrameIndex = 0;
				m_nMaxFrame = m_pAnimation->GetMaxFram();
				m_nState = Attack;
			}
		}

		//
		if(m_nState == Jump)
		{
			if(m_pRander->GetRanderFrameIndex()==3)
			{
				m_nState = JumpAir;
			}
		}

		//
		if(m_pAnimation != nullptr)
		{
			m_pRander = m_gRanderManeger->CreateRander(x, y, m_pAnimation->GetFrame(m_nCurrentFrameIndex);
			m_pRander->Ralate(bRalote);
		}
		m_nCurrentFrameIndex++;
	}
}

common.cpp
#include <string>
using namespace std;
vector<string> WL_Split(const string& str, const string& delims)
{
    vector<string> ret;

    size_t start, pos;
    start = 0;
    do 
    {
        pos = str.find_first_of(delims, start);
        if (pos == start)
        {
            start = pos + 1;
        }
        else if (pos == String::npos)
        {
            // Copy the rest of the string
            ret.push_back( str.substr(start) );
            break;
        }
        else
        {
            // Copy up to delimiter
            ret.push_back( str.substr(start, pos - start) );
            start = pos + 1;
        }
        // parse up to next real data
        start = str.find_first_not_of(delims, start);

    } while (pos != String::npos);

    return ret;
}

int StringToInt(string val)
{
    return atoi(val.c_str());
}

string IntToString(int val)
{
	return to_string(val);
}

WL_DB.h
#pragma once
#include <string>
#include <map>
#include <vector>
#include <sqlite3.h>
using namespace std;
class WL_DB
{
privete:
	sqlite3* m_pDB;
	string m_sErrMsg;
	static vector<map<string, string>> m_vecResult;
	string m_sFileName;

	static int callback(void *NotUsed, int argc, char **argv, char **azColName);
public:
	WL_DB(const string sFileName);
	virtual ~WL_DB();
	void OpenDB(const string sFileName);
	void Execute(const string sSql);
	void CloseDB();
	string GetError();
	vector<map<string, string>> GetResult();
	int GetRecordCount();
}
WL_DB.cpp
#include "WL_DB.h"
vector<map<string, string>> WL_DB::m_vecResult;
int WL_DB::callback(void *NotUsed, int argc, char **argv, char **azColName)
{
	map<string, string> map;
	for(i=0; i<argc; i++)
	{
		map[azColName[i]] = argv[i] ? argv[i] : "NULL";
	}
	m_vecResult.push_back(map);
	return 0;
}

WL_DB::WL_DB(const string sFileName)
{
	OpenDB(sFileName);
}

WL_DB::~WL_DB()
{
	CloseDB();
}

void WL_DB::OpenDB(const string sFileName)
{
	if(sqlite3_open(sFileName.c_str(), &m_pDB))
	{
		m_sErrMsg = sqlite3_errmsg(m_pDB);
		CloseDB();
		return;
	}
}

void WL_DB::Execute(const string sSql)
{
	char* zErrMsg = nullptr;
	if(m_pDB == nullptr)
	{
		m_sErrMsg =  "m_pDB is nullptr";
		return;
	}
	if(sqlite3_exec(m_pDB, sSql.c_str(), callback, 0, &zErrMsg))
	{
		m_sErrMsg = zErrMsg;
		sqlite3_free(zErrMsg);
	}
}

void WL_DB::CloseDB()
{
	sqlite3_close(m_pDB);
	m_pDB = null;
}

string WL_DB::GetError()
{
	return m_sErrMsg;
}

vector<map<string, string>> WL_DB::GetResult()
{
	return m_mapResult;
}

int WL_DB::GetRecordCount()
{
	return m_vecResult.size();;
}
tabledata file :.td
ObjectID:所有类型都是object，每个object都有唯一UUID，运行后都有一个ID，同类型的object的UUID相同，但是id不同。包括人物，怪物，物品。
WL_UI
UIID(ObjectID) Image describe
WL_Skill:public
SkillID name Attack CD TimeToLive
WL_Weapon:
WeaponID Attack Defence Effect EffectValue
WL_Armour
ArmourID Defence
WL_Item
ItemID 
WL_Monster
WL_Object
WL_Skill
BEGIN TRANSACTION;
CREATE TABLE WL_Animation (AnimationID TEXT, ObjectID TEXT, Type TEXT, Frame TEXT, Describe TEXT);
INSERT INTO WL_Animation VALUES(1,1,'Idel','1,2,3,4,5','Player Idle');
INSERT INTO WL_Animation VALUES(2,1,'Run','5,6,7,8,9','Player Run');
INSERT INTO WL_Animation VALUES(3,1,'Attack','10,11,12,13,14','Player Attack');
INSERT INTO WL_Animation VALUES(4,1,'Jump','15,16,17,18,19','Player Jump');
CREATE TABLE WL_Image (ImageID TEXT, FileName TEXT, FileSubName TEXT, SrcX TEXT, SrcY TEXT, Width TEXT, Height TEXT);
INSERT INTO WL_Image VALUES(1,'Idle\1.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(2,'Idle\2.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(3,'Idle\3.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(4,'Idle\4.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(5,'Run\1.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(6,'Run\2.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(7,'Run\3.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(8,'Run\4.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(9,'Attack\1.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(10,'Attack\2.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(11,'Attack\3.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(12,'Attack\4.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(13,'Jump\1.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(14,'Jump\2.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(15,'Jump\3.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(16,'Jump\4.png',NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(17,NULL,NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(18,NULL,NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(19,NULL,NULL,0,0,NULL,NULL);
INSERT INTO WL_Image VALUES(20,NULL,NULL,0,0,NULL,NULL);
CREATE TABLE WL_Role (RoleID TEXT, MaxHP TEXT, MaxMP TEXT, Describe TEXT);
INSERT INTO WL_Role VALUES(1,100,100,'Player');
COMMIT;

class WL_Animation
{
private:
	int m_nObjectID;
	int m_nTypeID;
	vector<int> m_vecFrame;
public:
	int Frame(int index);
	{
		m_vecFrame[index];
	}
}
/*
class WL_AnimationState
{
private:
	int m_nAnimationID;	
	int m_nCurrentFrameIndex;
private:
	int CurrentFrameIndex()
	{
		return m_nCurrentFrameIndex;
	}
}
*/
class WL_AnimationManager
{
private:
	map<int, WL_Animation*> mapAnimation;//int从1开始
public:
	WL_Animation* GetAnimation(int nAnimationID)
	{
		if (mapAnimation.find(nAnimationID) == mapAnimation.end())
    		return nullptr;
    	else
    		mapAnimation[nAnimationID];
	}
	WL_Animation* CreateAnimation(int nObjectID, int nTypeID)
	{
		WL_Animation* pAnimation = nullptr;
		do
		{
			int nAnimation = -1;
			int nSize = mapAnimation.size();
			for(int i = 1; i <= nSize; i++) 
			{
				if(mapAnimation[i].m_nObjectID == nObjectID && mapAnimation[i].m_nTypeID == nTypeID)
				{
					pAnimation = mapAnimation[i];
					break;
				}
			}
			if(nAnimation == -1)
			{
				string sSql = "select AnimationID, Frame from WL_Animation where ObjectID = " + IntToString(nObjectID) + " and TypeID = " + IntToString(nTypeID);
				m_gWL_DB->Execute(sSql);
				vector<map<string, string>> vecResult = m_gWL_DB->GetResult();
				if(vecResult.size() != 1)
				{
					pAnimation = nullptr;
					break;
				}
				WL_Animation* animation=new WL_Animation(nObjectID, nTypeID);
				mapAnimation[vecResult[0][AnimationID]] = animation;
				vector<string> vecFrame = WL_Split(vecResult[0][Frame], ",");
				int nSize = vecFrame.size();
				for(int i = 0; i < nSize; i++)
					animation->m_vecFrame.push_back(vecFrame[i]);
			}
		}while(flase)
		return pAnimation;
	}
};

class WL_Image
{
public:
	string m_sFileName;
	int m_nSrcX;
	int m_nSrcY;
	int m_nWidth;
	int m_nHeight;
}
class WL_ImageStore
{
private:
	map<int, WL_Image*> mapImage;
public:
	WL_Image* GetImage(int nImageId)
	{
		map<int, WL_Image*>::iterator iter = mapImage.find(nImageId);
		if(iter != mapImage.end())
		{
			return iter->second;
		}
		else
			return nullptr;
	}
}

class WL_RanderObject
{
public:
	int m_nDstX;
	int m_nDstY;
	float m_fAngle;
}

class WL_RanderManager 合并到scene
{
private:
	map<int, WL_RanderObject*> mapRanderObject;
public:
	void update()
	{
		CCSprite* sprite = nullptr;
		while()
		{
			sprite = getChildren();
			if (mapRanderObject.find(sprite->GetTag()) == mapAnimation.end())
	    		removeChild(sprite);
	    	else
	    	{
	    		WL_Image* image = m_gWL_ImageStore->GetImage(vecRanderObject[i].m_nImageID);
	    		sprite->setFrame(image->m_sFileName);
	    		sprite->setPosition(CCPoint(vecRanderObject[i].m_nDstX, vecRanderObject[i].m_nDstY));
	    	}
		}
	}
	void AddImage(int nImageId, int nDstX, nDstY, fAngle = 0)
	{
		WL_RanderObject* pRanderObject = new WL_RanderObject();
		pRanderObject.m_nDstX = nDstX;
		pRanderObject.m_nDstY = nDstY;
		pRanderObject.m_fAngle = fAngle;
		vecRanderObject[nImageId]=pRanderObject);
	}
}
WL_CollisionManager.h
WL_CollisionManager : public b2ContactListener
{
private:
	b2World *m_pWorld;
public:
	WL_CollisionManager();
	~WL_CollisionManager();
	void init();
	virtual void BeginContact(b2Contact* contact);
	virtual void EndContact(b2Contact* contact);
	void AddObject(WL_Object* pObject);
	void update();
};
WL_CollisionManager.cpp
WL_CollisionManager::WL_CollisionManager(b2Contact* contact)
{
	init();
}

void WL_CollisionManager::init()
{
	b2Vec2 gravity;
	gravity.Set(0.0f, 0.0f);
	m_pWorld = new b2World(gravity);
	m_pWorld->SetAllowSleeping(true);
	b2BodyDef groundBodyDef;
	groundBodyDef.position.Set(0, 0);
	b2Body *groundBody = _world->CreateBody(&groundBodyDef);
	b2EdgeShape groundBox;

	//bottom
	groundBox.Set(b2Vec2(VisibleRect::leftBottom().x / PTM_RATIO, VisibleRect::leftBottom().y / PTM_RATIO), b2Vec2(VisibleRect::rightBottom().x / PTM_RATIO, VisibleRect::rightBottom().y / PTM_RATIO));
	groundBody->CreateFixture(&groundBox, 0);
	//right
	//top
	//left
	m_pWorld->SetContactListener(this);
}

void WL_CollisionManager::BeginContact(b2Contact* contact)
{
	b2Body *bodyA = contact->GetFixtureA()->GetBody();
	b2Body *bodyB = contact->GetFixtureB()->GetBody();
	WL_Object* pObjectA = nullptr;
	WL_Object* pObjectB = nullptr;
	if(bodyA->GetUserData() != NULL && bodyB->GetUserData() != NULL) 
	{
		pObjectA = (WL_Object*)bodyA->GetUserData();
		pObjectB = (WL_Object*)bodyB->GetUserData();
		if(pObjectA->GetCollisionType() == pObjectB->GetType())
		{
			pObjectB->SetHp(pObjectB->GetHp - (pObjectA->GetAttack() * pObjectB->GetDefence() / MAX_DEFENCE));
		}
		else if(pObjectB->GetCollisionType() == pObjectA->GetType())
		{
			pObjectA->SetHp(pObjectA->GetHp - (pObjectB->GetAttack() * pObjectA->GetDefence() / MAX_DEFENCE));
		}
	}
}

void WL_CollisionManager::EndContact(b2Contact* contact)
{
	
}

void WL_CollisionManager::AddObject(WL_Object* pObject)
{
	b2BodyDef bodyDef;
	bodyDef.type = b2_dynamicBody;
	bodyDef.position.Set(pObject->getPositionX() / PTM_RATIO, pObject->getPositionY() / PTM_RATIO);
	bodyDef.userData = pObject;
	b2Body *body = m_pWorld->CreateBody(&bodyDef);

	int num = 4;
	b2Vec2 verts[] =
	{
		b2Vec2(pObject->Left() / PTM_RATIO, pObject->Top() / PTM_RATIO),
		b2Vec2(pObject->Right() / PTM_RATIO, pObject->Top() / PTM_RATIO),
		b2Vec2(pObject->Right() / PTM_RATIO, pObject->Buttom() / PTM_RATIO),
		b2Vec2(pObject->Left() / PTM_RATIO, pObject->Buttom() / PTM_RATIO)
	}
	b2FixtureDef fixtureDef;
	b2PolygonShape spriteShape;
	spriteShape.Set(verts, num);
	fixtureDef.shape = &spriteShape;
	fixtureDef.density = 10.0f;
	fixtureDef.isSensor = true;
	body->CreateFixture(&fixtureDef);
}
void WL_CollisionManager::update()
{
	m_pWorld->Step(dt, 10, 10);
}
script
mineskill.py
def begin():
//	mine = CreateObject("mine");
	mine->SetPosition(player1.x, player1.y, 0.1/*z value*/);
	mine->SetAnimation("Idle");
	mine->SetCollision(Points[4]);
	mine->AddCollisionObject(IDs[]);
def end():
	nodo
mineObject.py
def collision(objs):
	DeleteObject("mine");
	boom = CreateObject("boom");
	boom->SetPosition(item.x, item.y, 0.1/*z value*/);
//	fire = CreateObject("fire");
//	SetPosition(fire, this.x, this.y);
	DeleteObject("boom", delay);
	foreach obj in objs
		SaveData(obj, "boom");
fireObject.py
def collision(objs):
	booms = LoadData("boom");
	foreach obj in objs
		if obj is not in booms:
			SetCharacter(obj, HP, GetCharacter(obj, HP) - 100);

FireLineSkill.py
angle = target.x/player1.x;
nFrame = 0;
def begin():
	CreateObject("FireLine", player1.x, player1.y, angle, "FireLine", 0.1);
def runing():
	ScaleObject("FireLine", 0.05/*x*/, 1/*Y*/);
def end():
	nodo

